{"version":3,"sources":["webpack:///./src/appState.js","webpack:///./src/lib/createHeightMapRenderer.js","webpack:///./src/config.js","webpack:///./src/elevation.js","webpack:///./src/main.js"],"names":["appState","angle","currentState","lineDensity","lineWidth","smoothSteps","mapOpacity","heightScale","oceanLevel","aboutVisible","error","zazzleLink","generatingPreview","settingsOpen","shouldDraw","renderProgress","width","window","innerWidth","height","innerHeight","backgroundColor","r","g","b","a","lineBackground","lineColor","createHeightMapRenderer","regionInfo","canvas","renderHandle","render","cancel","cancelAnimationFrame","message","parse_float_default","parseFloat","style","opacity","ctx","getContext","lineStroke","getColor","lineFill","resHeight","resWidth","rowCount","Math","round","scale","_regionInfo$getAllHei","getAllHeightData","minHeight","maxHeight","rowWithHighestPoint","iteratorSettings","includeRowIndex","stepSize","start","floor","step","stop","createRegionIterator","heightRange","lastLine","lastRow","drawPolyLine","points","length","smoothRange","windowSize","result","max","Number","NEGATIVE_INFINITY","min","POSITIVE_INFINITY","i","leftOffset","from","to","count","sum","j","smoothHeight","getSmoothRange","beginPath","fillStyle","moveTo","lineTo","closePath","fill","strokeStyle","stroke","clearRect","fillRect","renderRows","now","performance","y","x","getHeightAtPoint","fY","push","elapsed","requestAnimationFrame","color","MAPBOX_TOKEN","apiURL","imageCache","getRegionElevation","map","progress","doneCallback","tileSize","tileZoom","transform","zoomPower","pow","coveringTiles","minzoom","maxzoom","tileBounds","reduce","bounds","tile","p","canonical","minX","minY","maxX","maxY","Infinity","document","createElement","Error","total","advanceProgress","heightsHandle","isCancelled","tilesToLoad","request","url","replace","z","getRequestForTile","cachedImage","get","promise_default","resolve","img","Image","onload","onerror","crossOrigin","src","set","then","image","drawImage","catch","finally","all","canvasWidth","data","getImageData","windowWidth","windowHeight","allHeights","Float32Array","done","timeQuota","lastY","collectHeights","startTime","index","getHeight","collectedHeights","console","log","lngLat","pointLocation","xTile","l","lng2tile","lng","xOffset","yTile","PI","tan","cos","lat2tile","lat","yOffset","yC","xC","R","G","B","decodeHeight","visibleHeights","api","undefined","completed","MapboxGeocoder","require","bind","__webpack_require__","oe","heightMapRenderer","regionBuilder","hideHeights","querySelector","updateMap","heightMapCanvas","display","init","mapboxgl","accessToken","Map","trackResize","container","minZoom","center","zoom","hash","addControl","NavigationControl","showCompass","on","once","getBearing","dragRotate","disable","touchZoomRotate","disableRotation","redraw"],"mappings":"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","file":"static/js/app.0310b1156f05df3568ae.js","sourcesContent":["const appState = {\n  angle: 0,\n  currentState: 'intro',\n  lineDensity: 28,\n  lineWidth: 1,\n  smoothSteps: 1,\n  mapOpacity: 100,\n  heightScale: 42,\n  oceanLevel: 0,\n  aboutVisible: false,\n  error: null,\n  zazzleLink: null,\n  generatingPreview: false,\n  settingsOpen: false,\n  shouldDraw: false,\n  renderProgress: null,\n  width: window.innerWidth,\n  height: window.innerHeight,\n\n  backgroundColor: {\n    r: 0xF7, g: 0xF2, b: 0xE8, a: 1\n  },\n  lineBackground: {\n    // r: 255, g: 255, b: 255, a: 1\n    r: 0xF7, g: 0xF2, b: 0xE8, a: 1\n  },\n  lineColor: {\n    r: 22, g: 22, b: 22, a: 1.0\n  },\n};\n\nexport default appState;\n\n\n// WEBPACK FOOTER //\n// ./src/appState.js","/**\n * This is the core component of the website which renders lines on the overlay\n * layer\n * @param {*} appState - @see ../appState.js\n * @param {*} map  - mapbox map instance\n * @param {*} canvas  - where the lines should be rendered\n */\nexport default function createHeightMapRenderer(appState, regionInfo, canvas) {\n  let renderHandle;\n\n  render();\n\n  return {\n    /**\n     * When new render request is created, we have to cancel the current one:\n     */\n    cancel,\n    render\n  }\n\n  function render() {\n    // let's set everything up to match our application state:\n    if (appState.renderProgress) {\n      appState.renderProgress.message = 'Rendering...'\n    }\n\n    const oceanLevel = Number.parseFloat(appState.oceanLevel);\n\n    let smoothSteps = parseFloat(appState.smoothSteps);\n\n    canvas.style.opacity = appState.mapOpacity/100;\n\n    let ctx = canvas.getContext('2d');\n    let lineStroke = getColor(appState.lineColor);\n    let lineFill = getColor(appState.lineBackground);\n    let lineWidth = Number.parseFloat(appState.lineWidth);\n\n    let resHeight = window.innerHeight;\n    let resWidth = window.innerWidth;\n    let rowCount = Math.round(resHeight * appState.lineDensity/100); \n    let scale = appState.heightScale;\n\n    // since tiles can be partially overlapped, we use our own iterator\n    // over partially overlapped tiles (to not deal with offset math here)\n    const {minHeight, maxHeight, rowWithHighestPoint} = regionInfo.getAllHeightData();\n    const iteratorSettings = createRegionIterator(rowCount, resHeight, rowWithHighestPoint);\n\n    // we want the scale be independent from the zoom level, use the distribution\n    // of heights as our scaler:\n    let heightRange = maxHeight - minHeight;\n\n    let lastLine = [];\n    let lastRow = iteratorSettings.start;\n\n    clearScene();\n    renderRows();\n\n    // Public part is over. Below is is just implementation detail\n\n    /**\n     * This renders rows, and stops if allowed time quota is exceeded (making rendering\n     * async, so that we do not freeze the main thread)\n     */\n    function renderRows() {\n      let now = performance.now();\n\n      for (let y = lastRow; y < iteratorSettings.stop; y += iteratorSettings.step) {\n        drawPolyLine(lastLine);\n        lastLine = [];\n\n        for (let x = 0; x < window.innerWidth; ++x) {\n          let height = regionInfo.getHeightAtPoint(x, y);\n          let fY = y - Math.floor(scale * (height - minHeight) / heightRange);\n\n          if (height <= oceanLevel) {\n            drawPolyLine(lastLine);\n            lastLine = [];\n          } else {\n            lastLine.push(x, fY);\n          }\n        }\n\n        lastRow = y + iteratorSettings.step;\n        let elapsed = performance.now() - now;\n        if (elapsed > 200) {\n          renderHandle = requestAnimationFrame(renderRows);\n          return;\n        }\n      }\n\n      drawPolyLine(lastLine);\n\n      appState.renderProgress = null;\n    }\n\n    /**\n     * Draws filled polyline.\n     */\n    function drawPolyLine(points) {\n      if (points.length < 3) return;\n\n      let smoothRange = getSmoothRange(points, smoothSteps);\n      points = smoothRange.points;\n\n      // If line's height is greater than 2 pixels, let's fill it:\n      if (smoothRange.max - smoothRange.min > 2) {\n        ctx.beginPath();\n        ctx.fillStyle = lineFill;\n        ctx.moveTo(points[0], points[1]);\n        for (let i = 2; i < points.length; i += 2) {\n          ctx.lineTo(points[i], points[i + 1]);\n        }\n        ctx.lineTo(points[points.length - 2], smoothRange.max);\n        ctx.lineTo(points[0], smoothRange.max);\n        ctx.closePath();\n        ctx.fill();\n      }\n\n      ctx.beginPath();\n      ctx.strokeStyle = lineStroke;\n      ctx.lineWidth = lineWidth;\n      ctx.moveTo(points[0], points[1]);\n      for (let i = 2; i < points.length; i += 2) {\n        ctx.lineTo(points[i], points[i + 1]);\n      }\n      ctx.stroke();\n    }\n\n    function clearScene() {\n      ctx.beginPath();\n      ctx.clearRect(0, 0, resWidth, resHeight);\n      ctx.fillStyle = getColor(appState.backgroundColor);\n      ctx.fillRect(0, 0, resWidth, resHeight);\n    }\n  }\n\n  function cancel() {\n    cancelAnimationFrame(renderHandle)\n    appState.renderProgress = null;\n  }\n\n  /**\n   * Simple smoothing function with moving averages, augmented with\n   * min/max calculation (don't want to spend more CPU cycles fo min/max)\n   */\n  function getSmoothRange(points, windowSize) {\n    let result = [];\n    let max = Number.NEGATIVE_INFINITY;\n    let min = Number.POSITIVE_INFINITY;\n    let length = points.length / 2;\n    for (let i = 0; i < length; i += 1) {\n      const leftOffset = i - windowSize;\n      const from = leftOffset >= 0 ? leftOffset : 0\n      const to = i + windowSize + 1;\n\n      let count = 0\n      let sum = 0\n      for (let j = from; j < to && j < length; j += 1) {\n        sum += points[2 * j + 1]\n        count += 1\n      }\n\n      let smoothHeight = sum / count;\n      result[2 * i] = points[2 * i];\n      result[2 * i + 1] = smoothHeight;\n\n      if (max < smoothHeight) max = smoothHeight;\n      if (min > smoothHeight) min = smoothHeight;\n    }\n\n    return {\n      points: result,\n      min,\n      max\n    };\n  }\n\n  /**\n   * Iterate over height map.\n   */\n  function createRegionIterator(rowCount, resHeight, includeRowIndex) {\n    let stepSize = Math.round(resHeight / rowCount);\n\n    return {\n      start: includeRowIndex - Math.floor(includeRowIndex/stepSize) * stepSize,\n      step: stepSize,\n      stop: resHeight\n    }\n  }\n\n  function getColor(color) {\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/createHeightMapRenderer.js","export const MAPBOX_TOKEN = 'pk.eyJ1IjoiYW52YWthIiwiYSI6ImNqaWUzZmhqYzA1OXMza213YXh2ZzdnOWcifQ.t5yext53zn1c9Ixd7Y41Dw';\n\n\n// WEBPACK FOOTER //\n// ./src/config.js","import { MAPBOX_TOKEN } from \"./config\";\n\nconst apiURL = `https://api.mapbox.com/v4/mapbox.terrain-rgb/zoom/tLong/tLat@2x.pngraw?access_token=${MAPBOX_TOKEN}`;\nlet imageCache = new Map();\n\nexport function loadImage(url) {\n  let cachedImage = imageCache.get(url);\n  if (!cachedImage) {\n    cachedImage = new Promise((resolve, error) => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(img);\n      };\n      img.onerror = error;\n      img.crossOrigin = \"anonymous\";\n      img.src = url;\n    });\n    imageCache.set(url, cachedImage);\n  }\n\n  return cachedImage;\n}\n\nfunction getTilesBounds(tiles) {\n  return tiles.reduce((bounds, tile) => {\n    let p = tile.canonical;\n    if (bounds.minX > p.x) bounds.minX = p.x;\n    if (bounds.minY > p.y) bounds.minY = p.y;\n    if (bounds.maxX < p.x) bounds.maxX = p.x;\n    if (bounds.maxY < p.y) bounds.maxY = p.y;\n\n    return bounds;\n  }, {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  })\n}\n\nexport function getRegionElevation(map, progress, doneCallback) {\n  if (!progress) progress = {};\n\n  const renderHD = true;\n\n  const tileSize = renderHD ? 512 : 256;\n  const tileZoom = map.transform.tileZoom;\n  const zoomPower = Math.pow(2, tileZoom);\n\n  const coveringTiles = map.transform.coveringTiles({\n    minzoom: tileZoom,\n    maxzoom: tileZoom,\n    tileSize\n  });\n\n  const tileBounds = getTilesBounds(coveringTiles);\n\n  const canvas = document.createElement(\"canvas\");\n  const width = tileBounds.maxX - tileBounds.minX;\n  const height = tileBounds.maxY - tileBounds.minY;\n  if (width > 50 || height > 50) throw new Error('Too many tiles requested. How did you do it?');\n\n  canvas.width = width * tileSize + tileSize;\n  canvas.height = height * tileSize + tileSize;\n  const ctx = canvas.getContext('2d');\n\n  const minX = tileBounds.minX;\n  const minY = tileBounds.minY;\n\n  progress.total = coveringTiles.length;\n\n  advanceProgress();\n\n  let heightsHandle;\n  let isCancelled = false;\n  const tilesToLoad = coveringTiles.map(toLoadedTile);\n\n  Promise.all(tilesToLoad)\n    .then(computeVisibleHeights)\n    .then(createAPI)\n    .then(api => {\n      if (!isCancelled) {\n        doneCallback(api)\n      }\n    });\n\n  return {\n    cancel() {\n      isCancelled = true;\n      cancelAnimationFrame(heightsHandle);\n    }\n  }\n\n  function createAPI(visibleHeights) {\n    let width = visibleHeights.windowWidth;\n    let data = visibleHeights.allHeights;\n\n    return {\n      getHeightAtPoint,\n      getAllHeightData() {\n        return visibleHeights;\n      }\n    };\n\n    function getHeightAtPoint(x, y) {\n      return data[x + y * width];\n    }\n  }\n\n  function computeVisibleHeights() {\n    const canvasWidth = canvas.width;\n    const data = ctx.getImageData(0, 0, canvasWidth, canvas.height).data;\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    let allHeights = new Float32Array(windowWidth * windowHeight);\n    let done;\n\n    let timeQuota = 16;\n    let minHeight = Infinity;\n    let maxHeight = -Infinity;\n    let rowWithHighestPoint = -1;\n    let lastY = 0;\n    heightsHandle = requestAnimationFrame(collectHeights); // todo let it be cancelled;\n\n    return new Promise((resolve) => { done = resolve });\n\n    function collectHeights() {\n      let startTime = window.performance.now();\n      for (let y = lastY; y < windowHeight; ++y) {\n        for (let x = 0; x < windowWidth; ++x) {\n          const index = y * windowWidth + x;\n          const height = getHeight(x, y);\n          allHeights[index] = height;\n          if (height < minHeight) minHeight = height;\n          if (height > maxHeight) {\n            maxHeight = height;\n            rowWithHighestPoint = y;\n          }\n        }\n        let elapsed = window.performance.now() - startTime;\n        if (elapsed > timeQuota) {\n          if (!isCancelled) heightsHandle = requestAnimationFrame(collectHeights);\n          return;\n        }\n        lastY = y;\n      }\n\n      window.collectedHeights = {\n        minHeight, maxHeight, \n        rowWithHighestPoint, \n        allHeights,\n        windowWidth,\n        windowHeight\n      };\n\n      console.log({\n        minHeight, maxHeight, \n        rowWithHighestPoint, \n        allHeights,\n        windowWidth,\n        windowHeight\n      });\n      done({\n        minHeight, maxHeight, \n        rowWithHighestPoint, \n        allHeights,\n        windowWidth,\n        windowHeight\n      });\n    }\n\n    function getHeight(x, y) {\n      let lngLat = map.transform.pointLocation({x, y})\n\n      let xTile = lng2tile(lngLat.lng, zoomPower);\n      let xOffset = (xTile - minX) * tileSize;\n      let yTile = lat2tile(lngLat.lat, zoomPower);\n      let yOffset = (yTile - minY) * tileSize;\n      let yC = Math.round(yOffset);\n      let xC = Math.round(xOffset);\n\n      let index = (yC * canvasWidth + xC) * 4;\n      let R = data[index + 0];\n      let G = data[index + 1];\n      let B = data[index + 2];\n\n      return decodeHeight(R, G, B)\n    }\n\n    function decodeHeight(R, G, B) {\n      let height = -10000 + ((R * 256 * 256 + G * 256 + B) * 0.1)\n      if (height < -100) {\n        // Fiji islands data has huge caves, which pushes the entire thing up.\n        // I'm reducing it.\n        height = height / 5000;\n      }\n      return height;\n    }\n  }\n\n  function toLoadedTile(tile) {\n    const request = getRequestForTile(tile);\n\n    return loadImage(request.url)\n      .then(drawTileImage)\n      .catch(drawBlankTile)\n      .finally(advanceProgress);\n\n    function drawTileImage(image) {\n      ctx.drawImage(image, request.x, request.y);\n    }\n\n    function drawBlankTile() {\n      ctx.beginPath();\n      ctx.fillStyle = '#0186a0'; // zero height\n      ctx.fillRect(request.x, request.y, tileSize, tileSize);\n    }\n  }\n\n  function getRequestForTile(tile) {\n    const p = tile.canonical;\n    const url = apiURL\n      .replace('zoom', p.z)\n      .replace('tLat', p.y)\n      .replace('tLong', p.x);\n\n    return {\n      url,\n      x: tileSize * (p.x - tileBounds.minX), \n      y: tileSize * (p.y - tileBounds.minY)\n    }\n  }\n\n  function advanceProgress() {\n    if (progress.completed === undefined) {\n      progress.completed = -1;\n    }\n    progress.completed = Math.min(progress.total, progress.completed + 1);\n    progress.message = `Downloading tiles: ${progress.completed} of ${progress.total}...`\n  }\n  \n}\n\nexport function lng2tile(l, zoomPower) {\n  let result = ((l + 180) / 360) * zoomPower;\n  return result;\n}\n\nexport function lat2tile(l, zoomPower) {\n  let angle = l * Math.PI / 180;\n  return (\n    ((1 - Math.log( Math.tan(angle) + 1 / Math.cos(angle)) /\n        Math.PI) /\n      2) * zoomPower \n  );\n}\n\nexport function tile2long(x, zoomPower) {\n  return (x / zoomPower) * 360 - 180;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/elevation.js","/**\n * This is the website startup point.\n */\nimport appState from \"./appState\";\nimport mapboxgl from \"mapbox-gl\";\nimport createHeightMapRenderer from \"./lib/createHeightMapRenderer\";\nimport { MAPBOX_TOKEN } from \"./config\";\nimport { getRegionElevation } from './elevation';\n\nvar MapboxGeocoder = require(\"@mapbox/mapbox-gl-geocoder\");\n\n// Load vue asyncronously\nrequire.ensure(\"@/vueApp.js\", () => {\n  require(\"@/vueApp.js\");\n});\n\n// Hold a reference to mapboxgl instance.\nlet map;\nlet heightMapRenderer;\nlet regionBuilder;\n// Let the vue know what to call to start the app.\nappState.init = init;\nappState.redraw = redraw;\nappState.updateMap = updateMap;\n\nfunction init() {\n  mapboxgl.accessToken = MAPBOX_TOKEN;\n\n  window.map = map = new mapboxgl.Map({\n    trackResize: true,\n    container: \"map\",\n    minZoom: 0,\n    style: \"mapbox://styles/mapbox/light-v10\",\n    //11.08/33.3849/-118.4432\n    center: [-118.4432, 33.3849],\n    zoom: 11.08,\n    hash: true\n  });\n\n  map.addControl(\n    new mapboxgl.NavigationControl({ showCompass: false }),\n    \"bottom-right\"\n  );\n  map.addControl(new MapboxGeocoder({ accessToken: mapboxgl.accessToken }));\n  map.on('moveend', function() {\n    map.once('idle', updateMap)\n  });\n  map.on(\"movestart\", hideHeights);\n  map.on(\"load\", function() {\n    appState.angle = map.getBearing();\n    // map.showTileBoundaries = true;\n  });\n\n  map.dragRotate.disable();\n  map.touchZoomRotate.disableRotation();\n}\n\nfunction hideHeights() {\n  appState.zazzleLink = null;\n  let canvas = document.querySelector(\".height-map\");\n  if (canvas) canvas.style.opacity = 0.02;\n}\n\nfunction redraw() {\n  if (!heightMapRenderer) return;\n  heightMapRenderer.cancel();\n  heightMapRenderer.render();\n}\n\nfunction updateMap() {\n  if (!map) return;\n\n  let heightMapCanvas = document.querySelector(\".height-map\");\n  if (!heightMapCanvas) return;\n\n  if (heightMapRenderer) {\n    heightMapRenderer.cancel();\n  }\n  if (regionBuilder) {\n    regionBuilder.cancel();\n  }\n\n  if (!appState.shouldDraw) {\n    heightMapCanvas.style.display = \"none\";\n    return;\n  } else {\n    heightMapCanvas.style.display = \"\";\n  }\n  \n  appState.renderProgress = {\n    message: '',\n    isCancelled: false,\n    completed: false\n  };\n\n  // This will fetch all heightmap tiles\n  regionBuilder = getRegionElevation(map, appState.renderProgress, showRegionHeights)\n\n  function showRegionHeights(regionInfo) {\n    heightMapRenderer = createHeightMapRenderer(appState, regionInfo, heightMapCanvas);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js"],"sourceRoot":""}